---
layout:     post
title:      Orange'S：一个操作系统的实现
subtitle:   进程
date:       2019-11-06
header-img: img/post-first-blog-web.jpg
catalog: true
tags:
    - x86
    - 操作系统
    - 进程

---

### 介绍

进程示意图

![](https://raw.githubusercontent.com/dbb4560/StorePicturebed/master/wirtePicture/20191127222551.png)

进程涉及到进程调度！ 书上是说一个进程只干一件事，有很多种进程，也就是CPU 只能运行一个进程，其他进程正在等待！

所以需要一个数据结构记录一个进程的状态，在进程被挂起的时候，进程信息就被写入这个数据结构，等到进程重启的时候，这个信息就重新被读取出来！

实际上进程和进程调度室运行在不同的层级上。

书上举例都是让任务运行在ring1，进程切换运行在ring0.

典型的就是发生时钟中断，时钟中断发生时，中断处理程序会将控制权交给进程调度模块。这时候系统认为应该进行进程切换，进程切换就发生了！当前的进程的状态就被保存起来，队列中的下一个进程将被恢复执行。同一时刻，只能有一个进程处在运行态！（注意，并非每个时钟中断都一定会发生进程切换）。

作者提到是参考minix系统简化的，基本都是拿来主义的！

有兴趣可以直接看minix！

![](https://raw.githubusercontent.com/dbb4560/StorePicturebed/master/wirtePicture/20191127225412.png)

### 最简单的进程

情况是  一个进程运行中，发生了时钟中断，特权级从ring1 到 ring0 ，开始执行时钟中断处理程序，中断处理程序这时调用进程调度模块，指定下一个应该运行的进程，当中断处理程序结束时，下一个进程准备就绪并开始运行，特权级从ring0 跳回ring1

- 进程A 运行
- 时钟中断发生，ring1-> ring0 ，时钟中断处理程序启动。
- 进程调度，下一个应运行的进程（假设进程B）被指定。
- 进程B被恢复，ring0-> ring1 。
- 进程B 运行中！


根据要求，需要实现的功能如下：

- 时钟中断处理程序
- 进程调度模块
- 两个进程

![](https://raw.githubusercontent.com/dbb4560/StorePicturebed/master/wirtePicture/20191127225959.png)


首先要保存CPU 寄存器的值！ 不但有push 也有pushad 一条指令可以保存许多寄存器的值！这些代码放在时钟中断最顶端，以便于中断发生时马上被执行！ 自然恢复时pop ，执行iretd就回到进程B了


### 进程表

PCB 进程表简称，我们会有很多进程

进程表用来描述进程的，必须独立于进程之外的！ 当把寄存器值压到进程表内的时候，已经处在进程管理模块之中了！

当寄存器的值已经被保存到进程表内，进程调度就开始执行了，那么esp指向何处呢？


因为进程调度模块会用到堆栈，寄存器的值被压到进程表之后，esp是指向进程表某个位置的。如果接下来的堆栈操作，会破坏进程表的值，从而下一次进程恢复时产生严重错误！

为解决这个问题，书上说是将esp指向专门的内核栈区域。这样，短短的进程切换过程中，esp的位置出现在3个不同的区域！


- 进程栈
- 进程表
- 内核栈


具体编写代码，一定要弄清楚当前使用时哪个堆栈！


### 特权级变换 ring1-> ring0

对于有特权级变换的转移，如果由外层向内层转移，需要从TSS 中取得从当前TSS中取出内层ss和esp作为目标代码的ss和esp。所以我们必须事先准备好TSS。因为每个进程相对独立，我们把涉及到的描述符放在局部描述符表LDT中，所以，我们还需要为每个进程准备LDT!

书上说，开始的第一个进程，使用iretd 来实现ring0 - ring1 的转移，一旦转移成功，就认为在一个进程中运行了！

 代码在chapter6/r/kernel/kernel.asm

```

354	; ====================================================================================
355	;				    restart
356	; ====================================================================================
357	restart:
358		mov	esp, [p_proc_ready]
359		lldt	[esp + P_LDT_SEL]
360		lea	eax, [esp + P_STACKTOP]
361		mov	dword [tss + TSS3_S_SP0], eax
362	restart_reenter:
363		dec	dword [k_reenter]
364		pop	gs
365		pop	fs
366		pop	es
367		pop	ds
368		popad
369		add	esp, 4
370		iretd

```

进程对我的确是新鲜的事物，本人按照书上，进行复述！

在kernel文件下，有一个main.c，里面有一个函数kernel_main()，函数的后面有一个restart();  就是上面的那段代码！

它是进程的一部分，也是我们操作系统启动第一个进程时的入口！

分析代码

第358行 `358		mov	esp, [p_proc_ready] `设置了esp的值，

p_proc_ready 是指向进程表的指针，存放的便是下一个要启动进程表的地址。

其中内容必然是以图所示的顺序进行存放

![](https://raw.githubusercontent.com/dbb4560/StorePicturebed/master/wirtePicture/20191128215309.png)

这样才会使pop和popad指令执行后各寄存器的内容更新一遍！

查看代码可得知，p_proc_ready 在global.h定义，是结构类型指针，struct s_proc*，再打开proc.h，可以看到s_proc这个结构体第一个成员也是一个结构，s_stackframe。

原来的进程状态都被存放在s_proc这个结构体中，而且位于前部的是所有相关寄存器的值，s_proc这个结构应该是我们提到进程表。

当恢复一个进程时，便将esp指向这个结构体的开始处，然后运行一系列的pop命令将寄存器弹出。进程表的开始位置结构图如图所示！

![](https://raw.githubusercontent.com/dbb4560/StorePicturebed/master/wirtePicture/20191128215838.png)

在第359行 ` 359		lldt	[esp + P_LDT_SEL] `

lldt是设置ldtr的，esp等同于p_proc_ready,那么esp+ P_LDT_SEL一定是s_proc的一个成员