---
layout:     post
title:      x86汇编语言-从实模式到保护模式笔记
subtitle:   全局描述符表（GDT）
date:       2019-10-24
header-img: img/post-first-blog-web.jpg
catalog: true
tags:
    - x86
    - GDT
    - 保护模式
  
---

### 全局描述符表（GDT）

在进入保护模式之前。首先来介绍一下，全局描述符表（Global Descriptor Table，GDT）。



在实模式下，处理器将内存分为逻辑上的段，在访问内存时，在指令中，使用段内偏移地址。这在之前的文章学习的很深刻了。

在保护模式下，就不太一样了。对内存的访问，依然使用段地址加偏移地址，但是，在每个段能够进行访问之前，必须先进行登记。


但在保护模式下就不行了，开公司之前必须先登记，登记的信息包括住址（段的起始地址）、经营项目（段的界限等各种访问属性）。这样，每当你做的买卖和项目不符时，就会被阻止。对段的访问也是一样，当你访问的偏移地址超出段的界限时，处理器就会阻止这种访问，并产生一个叫做内部异常的中断。

和一个段有关的信息需要 8 个字节来描述，所以称为段描述符（Segment Descriptor），每个段都需要一个描述符。为了存放这些描述符，需要在内存中开辟出一段空间。在这段空间里，所有的描述符都是挨在一起，集中存放的，这就构成一个描述符表!

最主要的描述符表是全局描述符表（Global Descriptor Table， GDT），所谓全局，意味着该表是为整个软硬件系统服务的。在进入保护模式前，必须要定义全局描述符表。

如图 11-1 所示，为了跟踪全局描述符表，处理器内部有一个 48 位的寄存器，称为全局描述符表寄存器（GDTR）。

![](https://raw.githubusercontent.com/dbb4560/StorePicturebed/master/wirtePicture/20191024214921.png)

该寄存器分为两部分，分别是 32 位的线性地址和 16 位的边界。

32 位的处理器具有 32 根地址线，可以访问的地址范围是 0x00000000 到 0xFFFFFFFF，共 232字节的内存，即 4GB 内存。

GDTR 的 32 位线性基地址部分保存的是全局描述符表在内存中的起始线性地址!

16 位边界部分保存的是全局描述符表的边界（界限），其在数值上等于表的大小（总字节数）减一! (作者提到 “全局描述符表的界限值就是表内最后 1 字节的偏移量” 我也没搞懂1字节的偏移量是什么鬼！反正总字节数减1就行了！ )

因为 GDT 的界限是 16 位的，所以，该表最大是 216 字节，也就是 65536 字节（64KB）。又因为一个描述符占 8 字节，故最多可以定义 8192 个描述符。实际上，不一定非得这么多，到底有多少，视需要而定，但最多不能超过 8192 个!

理论上，全局描述符表可以位于内存中的任何地方。但是，如图 11-2 所示，由于在进入保护模式之后，处理器立即要按新的内存访问模式工作，所以，必须在进入保护模式之前定义 GDT。但是，由于在实模式下只能访问 1MB 的内存，故 GDT 通常都定义在 1MB 以下的内存范围中。当然，允
许在进入保护模式之后换个位置重新定义 GDT。

![](https://raw.githubusercontent.com/dbb4560/StorePicturebed/master/wirtePicture/20191024222220.png)

### 存储器的段描述符

在程序的开始部分要初始化段寄存器。代码清单 11-1 第 7～9 行用于初始化堆栈，使堆栈段的逻辑段地址和代码段相同，并使堆栈指针寄存器 SP 指向 0x7c00。这是个分界线，从这里，代码向上扩展，而堆栈向下扩展！

代码如下：

```
1 			 ;代码清单11-1
2 			 ;文件名：c11_mbr.asm
3 			 ;文件说明：硬盘主引导扇区代码 
4 			 ;创建日期：2011-5-16 19:54
5 
6 			 ;设置堆栈段和栈指针 
7 			 mov ax,cs      
8 			 mov ss,ax
9 			 mov sp,0x7c00
10		  
11			 ;计算GDT所在的逻辑段地址 
12			 mov ax,[cs:gdt_base+0x7c00]        ;低16位 
13			 mov dx,[cs:gdt_base+0x7c00+0x02]   ;高16位 
14			 mov bx,16        
15			 div bx            
16			 mov ds,ax                          ;令DS指向该段以进行操作
17			 mov bx,dx                          ;段内起始偏移地址 
18		  
19			 ;创建0#描述符，它是空描述符，这是处理器的要求
20			 mov dword [bx+0x00],0x00
21			 mov dword [bx+0x04],0x00  
22
23			 ;创建#1描述符，保护模式下的代码段描述符
24			 mov dword [bx+0x08],0x7c0001ff     
25			 mov dword [bx+0x0c],0x00409800     
26
27			 ;创建#2描述符，保护模式下的数据段描述符（文本模式下的显示缓冲区） 
28			 mov dword [bx+0x10],0x8000ffff     
29			 mov dword [bx+0x14],0x0040920b     
30
31			 ;创建#3描述符，保护模式下的堆栈段描述符
32			 mov dword [bx+0x18],0x00007a00
33			 mov dword [bx+0x1c],0x00409600
34
35			 ;初始化描述符表寄存器GDTR
36			 mov word [cs: gdt_size+0x7c00],31  ;描述符表的界限（总字节数减一）   
37												 
38			 lgdt [cs: gdt_size+0x7c00]
39		  
40			 in al,0x92                         ;南桥芯片内的端口 
41			 or al,0000_0010B
42			 out 0x92,al                        ;打开A20
43
44			 cli                                ;保护模式下中断机制尚未建立，应 
45												;禁止中断 
46			 mov eax,cr0
47			 or eax,1
48			 mov cr0,eax                        ;设置PE位
49		  
50			 ;以下进入保护模式... ...
51			 jmp dword 0x0008:flush             ;16位的描述符选择子：32位偏移
52												;清流水线并串行化处理器 
53			 [bits 32] 
54
55		flush:
56			 mov cx,00000000000_10_000B         ;加载数据段选择子(0x10)
57			 mov ds,cx
58
59			 ;以下在屏幕上显示"Protect mode OK." 
60			 mov byte [0x00],'P'  
61			 mov byte [0x02],'r'
62			 mov byte [0x04],'o'
63			 mov byte [0x06],'t'
64			 mov byte [0x08],'e'
65			 mov byte [0x0a],'c'
66			 mov byte [0x0c],'t'
67			 mov byte [0x0e],' '
68			 mov byte [0x10],'m'
69			 mov byte [0x12],'o'
70			 mov byte [0x14],'d'
71			 mov byte [0x16],'e'
72			 mov byte [0x18],' '
73			 mov byte [0x1a],'O'
74			 mov byte [0x1c],'K'
75
76			 ;以下用简单的示例来帮助阐述32位保护模式下的堆栈操作 
77			 mov cx,00000000000_11_000B         ;加载堆栈段选择子
78			 mov ss,cx
79			 mov esp,0x7c00
80
81			 mov ebp,esp                        ;保存堆栈指针 
82			 push byte '.'                      ;压入立即数（字节）
83			 
84			 sub ebp,4
85			 cmp ebp,esp                        ;判断压入立即数时，ESP是否减4 
86			 jnz ghalt                          
87			 pop eax
88			 mov [0x1e],al                      ;显示句点 
89		  
90	  ghalt:     
91			 hlt                                ;已经禁止中断，将不会被唤醒 
92
93	;-------------------------------------------------------------------------------
94		 
95			 gdt_size         dw 0
96			 gdt_base         dd 0x00007e00     ;GDT的物理地址 
97								 
98			 times 510-($-$$) db 0
99							  db 0x55,0xaa

```

在保护模式下，内存的访问机制完全不同，即，必须通过描述符来进行。所以，这些段必须重新在 GDT 中定义。

先是确定 GDT 的起始线性地址。代码清单 11-1第 96 行，声明了标号 gdt_base 并初始化了一个双字0x00007e00，我们决定从这个地方开始创建全局描述符表（GDT）。这是有意的，如图 11-3 所示，在实模式下，主引导程序的加载位置是 0x0000:0x7c00，也就是物理地址 0x07c00。


![](https://raw.githubusercontent.com/dbb4560/StorePicturebed/master/wirtePicture/20191024223001.png)

因为现在的地址是 32 位的，所以它现在对应着物理地址 0x00007c00。主引导扇区程序共 512（0x200）字节，所以，我们决定把 GDT 设在主引导程序之后，也就是物理地址 0x00007e00 处。
因为 GDT 最大可以为 64KB，所以，理论上，它的尺寸可以扩展到物理地址 0x00017dff 处。

因为堆栈指针寄存器 SP 被初始化为0x7c00，和 CS 一样，堆栈段寄存器 SS 被初始化为0x0000，而且堆栈是向下扩展的，所以，从 0x00007c00
往下的区域是实际上可用的堆栈区域。只不过，该区域包含了很多 BIOS 数据，包括实模式下的中断向量表，所以一定要小心。这是没有办法的事，在实模式下，处理器不会为此负责，只能靠你自己。


一旦确定了 GDT 在内存中的起始位置，下一步的工作就是确定要访问的段，并在 GDT 中为这些段创建各自的描述符。

如图 11-4 所示，每个描述符在 GDT 中占 8 个字节，也就是 2 个双字，或者说是 64 位。图中，下面是低 32 位，上面是高 32 位。


![](https://raw.githubusercontent.com/dbb4560/StorePicturebed/master/wirtePicture/20191024223819.png)

很明显，描述符制定了32位的段起始地址（段基地址），以及20位的段边界。

在32位模式下，段地址与实模式下的段地址不一样。在实模式先段地址不是真正的物理地址，它还需要左移4位。而保护模式下，段地址是32位的线性地址，它就是真实的物理地址（未开启分页功能，分页功能后面学习）。

描述符中段基址和段界限不是连续的。这是历史的问题与兼容的问题。

20位的段界限是用来限制段的扩展范围。因为访问内存的方法是用段基地址加上偏移量，所以，对于向上扩展的段，如代码段和数据段来说，偏移量是从 0 开始递增， 段界限决定了偏移量的最大值； 对于向下扩展的段，如堆栈段来说， 段界限决定了偏移量的最小值。

下面来介绍段描述符各个字段的意思。

### 段描述符各个字段的意义

下面的表格列出了上述段描述符的各个位的意思，如果现在不理解这些位也无所谓，后面的学习会慢慢深入理解。

| G： 粒度位 | 用于解释段界限的含义。当G位是0时，段界限以字节为单位。此时段的扩展范围是从1字节到1M字节，因为描述符中的界限值是20位的。相反，如果该位是1，那么段界限是以4KB位单位。这样段的扩展范围是4KB到4GB | 
| S： 类 型 位 |	当该位是0时，表示是一个系统；为1时，表示是一个代码段或者数据段（栈段也是特殊的数据段）。系统段将在后面的文章中学习
| DPL 特权级 | 这两位用于指定描述符的特权级。共有4中处理器支持的特权级别，分别是0、1、2、3 ，其中0是最高的特权级，3是最低的特权级别。刚进入保护模式时执行的代码具有最高特权级0（可以看成是从处理器那里继承来的）这些代码通常是操作系统代码，因此它的特权级最高。每当操作系统加载一个用户程序，它通常都会制定一个低的特权级，比如3特权级。不同特权级的程序是互相隔离的，其访问是严格限制的，而且有些处理器指令只能由0特权级的程序来执行，为的就是安全。在这里，描述符的特权级是用于指定访问该段所必须具有的最低特权级。|
|P： 段存在位 | P位用于指示描述符所对应的段是否存在。一般来说，描述符所对应的段是在内存中。但是当内存空间紧张时，有可能指示建立了描述符，对应的内存空间并不存在，这时就应当把描述符的P位清零，表示段并不存在。另外，同样是在内存空间紧张的情况下，会把很少用到的段换出到硬盘中，腾出空间给当前急需内存的进程使用，这时同样要把P位清零，当再次轮到它执行时，再将其装入内存，然后P位置1。 **P是由处理器负责检查的。**每当通过描述符访问内存段时，如果P位是0，处理器就会产生一个异常中断。通常，该中断处理过程是由操作系统提供的，该处理过程的任务是将该段从硬盘换回内存，并将P位置1。在多用户、多任务的系统中，这是一种常用的虚拟内存调度策略。|
| D/B: 默认的操作数大小 |	设置该标志位，主要是为了能够在32位处理器上兼容运行16位保护模式的程序。 该标志位对不同的段有不同的效果。对于代码段，此位称为D位，用于指定指令中默认的的偏移地址和操作数尺寸。D=0时表示指令中的偏移地址或者操作数是16位的。D=1时，表示32位的偏移地址和操作数。对于栈段来说，该位是B位，用于在进行隐式的栈操作中（push，pop，call等），是使用SP寄存器还是使用ESP寄存器。当B=0时，在访问哪个段时，使用SP寄存器，否则就使用ESP寄存器。同时，B位的值，也决定了栈段的上边界。如果B=0，那么栈的上边界是0xFFFF；如果B=1，那么栈段的上边界是0xFFFFFFFF。 |
| L：64位代码段标志 |	保留此位给64位处理器使用。目前我们将它置0即可 |
| TYPE：描述符子类型 |	对于数据段来说，这4位分别是X,E,W,A，对于代码段来说这4位分别是X,C,R,A。他们具体的含义见下面的表格。 |
| AVL:软件可以使用的位 |	通常由操作系统来用，处理器并不使用它。|

下面表格是代码段和数据段的TYPE字段


| X | E | W | A | 描述符类别 | 含义
| 0 | 0 | 0 | X | 数据段     | 只读
| 0 | 0	| 1	| X	| 数据段	    | 读、写
| 0	| 1	| 0	| X	| 数据段 	| 只读，向下扩展
| 0	| 1	| 1	| X	| 数据段	    | 读、写，向下扩展