---
layout:     post
title:      汇编语言学习1
subtitle:   前言
date:       2019-08-09
header-img: img/post-first-blog-web.jpg
catalog: true
tags:
    - 汇编语言
    - linux
    - Intel8086
    
---
# 前言

>好好学习汇编语言，为后面学习打好基础！


#汇编语言的产生
我们知道机器只能看懂机器语言，也就是0和1。实际上0和1只是我们规定的数字，机器其实连0和1也看不懂，这里的0和1实际上是指两种不同的电压状态，计算机是用电的，它能理解的就是电压的变化，所以我们通过不同的电压驱动计算机运算，来完成我们所需要的任务。

计算机刚刚发明的时候，用的是就是最原始的方法，通过过纸带来编程，打孔的地方表示1，不打孔的地方表示0，然后将纸带输入计算机中。这种方式不但费时费力，而且不同发现错误。

比如下面的打纸
101110000000000000000011 000001010000000000110000 001011010000000000000101

- 1
- 2
- 3

这是8086CPU完成运算s=768+12288-1280的程序

汇编语言有三类指令组成

- 汇编指令 机器码助记符，有对应的机器码
- 伪指令 没有对应的机器码，由编译器执行，计算并不执行
- 其他符号： 如+、-、*、/ 等，由编译器识别，没有对应的机器码

汇编语言的核心是汇编指令

#CPU对存储器的读写
我们知道数据和指令是放在内存中的，CPU通过总线对存储器进行访问，但实际上总线是分为三部分的，即地址线，控制线和数据线。地址线表示CPU要对内存中的哪个地址进行操作，所以地址线的条数决定了CPU能够访问的内存范围，因为一根线上最多只能有两种不同的状态即0和1，所以10根地址线能够访问的存储单元的个数就是2^10个。

地址线仅仅是送出了要操作的地址，但是并没有声明要进行什么操作，所以控制线就是来决定对存储单元的操作的。所以说控制线的条数决定了CPU能够执行的操作的种类。

数据线是用来在CPU和内存之间进行数据传送的，所以数据线的条数决定了一次最多传送的数据的数量，例如8根数据线一次就能传送8个bit即一个字节。

![](https://raw.githubusercontent.com/dbb4560/StorePicturebed/master/wirtePicture/image20190809223222.png)

上图展示了CPU从3号内存单元中读取数据的过程。首先CPU利用数据线送出地址3，然后通过控制线发送读命令，然后内存将结果通过数据线返回给CPU。

# 内存地址空间
什么是内存地址空间呢？举例来讲，一个CPU的地址总线宽度为10，那么可以寻址1024个内存单元，这1024个可寻到的内存单元就构成了这个CPU的内存地址空间。当然这里所说的内存并不单单是内存条中的内存，还包括其他各种外设中的RAM和ROM。例如，显卡也有自己的内存，用来存储在显示屏上显示的内容，另外显卡BIOS ROM也被当做是内存空间中的一部分，此外还有网卡的BIOS ROM和系统BIOS ROM地址空间等。

因此我们在基于一个计算机硬件系统编程时，必须要知道这个系统中的内存地址空间分配情况。应为当我们想在某类存储器中读写数据的时候，必须知道它的第一个单元地址和最后一个单元地址，才能保证读写操作是在预期的存储器中进行的。比如，我们希望在显示器上输出一段信息，那么必须将这段信息写到显存中，显卡才能将它输出到显示器上，要想向显存中写入数据，必须知道显存在地址空间中的地址。

![](https://raw.githubusercontent.com/dbb4560/StorePicturebed/master/wirtePicture/image20190809223710.png)

上图展示了8086PC机内存地址空间分配的基本情况。从地址0~9FFFF的内存单元中读取数据，实际上就是在读取住随机存储器中的数据；向地址A0000~BFFFF的内存单元中写数据，就是向显示器中写入数据，这些数据会被显卡显示到显示器上；我们向C0000~FFFFFF的内存单元中写入数据的操作是无效的，因为这等于改写只读存储器中的内容。