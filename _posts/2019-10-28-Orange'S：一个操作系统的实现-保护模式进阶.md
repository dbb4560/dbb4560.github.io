---
layout:     post
title:      Orange'S：一个操作系统的实现
subtitle:   保护模式进阶
date:       2019-10-28
header-img: img/post-first-blog-web.jpg
catalog: true
tags:
    - x86
    - 操作系统
    - 保护模式
    - 进阶
  
---

### 保护模式进阶

之前讲述了进入保护模式的步骤！

复习一下：

1. 定义GDT
2. 用lgdt 加载 gdtr
3. 打开A20 地址线
4. 设置CR0 寄存器PE位为1
5. 执行跳转，进入保护模式

在保护模式下，我们能访问4G 的内存！

所以试验一下读写大地址内存！
思路：
新建一个段，以5mb为基址，这个远超出1MB 的界限了。 先读出开始处8字节的内容，然后写入一个字符串，再从中读出8个字节。 这个读出来的字节就跟写入的字符串一样！ 字符串保存在数据段中，数据段属于新加的，因为上一章只定义了三个描述符，一个空描述符，一个代码段描述符，一个显存描述符。



书中也提供了代码 chapter3/b/pmtest2.asm


代码清单：

```

1  	; ==========================================
2  	; pmtest2.asm
3  	; 编译方法：nasm pmtest2.asm -o pmtest2.com
4  	; ==========================================
5  
6  	%include	"pm.inc"	; 常量, 宏, 以及一些说明
7  
8  		org	0100h
9  		jmp	LABEL_BEGIN
10 
11 	[SECTION .gdt]
12 	; GDT
13 	;                            段基址,        段界限 , 属性
14 	LABEL_GDT:         Descriptor    0,              0, 0         ; 空描述符
15 	LABEL_DESC_NORMAL: Descriptor    0,         0ffffh, DA_DRW    ; Normal 描述符
16 	LABEL_DESC_CODE32: Descriptor    0, SegCode32Len-1, DA_C+DA_32; 非一致代码段, 32
17 	LABEL_DESC_CODE16: Descriptor    0,         0ffffh, DA_C      ; 非一致代码段, 16
18 	LABEL_DESC_DATA:   Descriptor    0,      DataLen-1, DA_DRW    ; Data
19 	LABEL_DESC_STACK:  Descriptor    0,     TopOfStack, DA_DRWA+DA_32; Stack, 32 位
20 	LABEL_DESC_TEST:   Descriptor 0500000h,     0ffffh, DA_DRW
21 	LABEL_DESC_VIDEO:  Descriptor  0B8000h,     0ffffh, DA_DRW    ; 显存首地址
22 	; GDT 结束
23 
24 	GdtLen		equ	$ - LABEL_GDT	; GDT长度
25 	GdtPtr		dw	GdtLen - 1	; GDT界限
26 			dd	0		; GDT基地址
27 
28 	; GDT 选择子
29 	SelectorNormal		equ	LABEL_DESC_NORMAL	- LABEL_GDT
30 	SelectorCode32		equ	LABEL_DESC_CODE32	- LABEL_GDT
31 	SelectorCode16		equ	LABEL_DESC_CODE16	- LABEL_GDT
32 	SelectorData		equ	LABEL_DESC_DATA		- LABEL_GDT
33 	SelectorStack		equ	LABEL_DESC_STACK	- LABEL_GDT
34 	SelectorTest		equ	LABEL_DESC_TEST		- LABEL_GDT
35 	SelectorVideo		equ	LABEL_DESC_VIDEO	- LABEL_GDT
36 	; END of [SECTION .gdt]
37 
38 	[SECTION .data1]	 ; 数据段
39 	ALIGN	32
40 	[BITS	32]
41 	LABEL_DATA:
42 	SPValueInRealMode	dw	0
43 	; 字符串
44 	PMMessage:		db	"In Protect Mode now. ^-^", 0	; 在保护模式中显示
45 	OffsetPMMessage		equ	PMMessage - $$
46 	StrTest:		db	"ABCDEFGHIJKLMNOPQRSTUVWXYZ", 0
47 	OffsetStrTest		equ	StrTest - $$
48 	DataLen			equ	$ - LABEL_DATA
49 	; END of [SECTION .data1]
50 
51 
52 	; 全局堆栈段
53 	[SECTION .gs]
54 	ALIGN	32
55 	[BITS	32]
56 	LABEL_STACK:
57 		times 512 db 0
58 
59 	TopOfStack	equ	$ - LABEL_STACK - 1
60 
61 	; END of [SECTION .gs]
62 
63 
64 	[SECTION .s16]
65 	[BITS	16]
66 	LABEL_BEGIN:
67 		mov	ax, cs
68 		mov	ds, ax
69 		mov	es, ax
70 		mov	ss, ax
71 		mov	sp, 0100h
72 
73 		mov	[LABEL_GO_BACK_TO_REAL+3], ax
74 		mov	[SPValueInRealMode], sp
75 
76 		; 初始化 16 位代码段描述符
77 		mov	ax, cs
78 		movzx	eax, ax
79 		shl	eax, 4
80 		add	eax, LABEL_SEG_CODE16
81 		mov	word [LABEL_DESC_CODE16 + 2], ax
82 		shr	eax, 16
83 		mov	byte [LABEL_DESC_CODE16 + 4], al
84 		mov	byte [LABEL_DESC_CODE16 + 7], ah
85 
86 		; 初始化 32 位代码段描述符
87 		xor	eax, eax
88 		mov	ax, cs
89 		shl	eax, 4
90 		add	eax, LABEL_SEG_CODE32
91 		mov	word [LABEL_DESC_CODE32 + 2], ax
92 		shr	eax, 16
93 		mov	byte [LABEL_DESC_CODE32 + 4], al
94 		mov	byte [LABEL_DESC_CODE32 + 7], ah
95 
96 		; 初始化数据段描述符
97 		xor	eax, eax
98 		mov	ax, ds
99 		shl	eax, 4
100		add	eax, LABEL_DATA
101		mov	word [LABEL_DESC_DATA + 2], ax
102		shr	eax, 16
103		mov	byte [LABEL_DESC_DATA + 4], al
104		mov	byte [LABEL_DESC_DATA + 7], ah
105
106		; 初始化堆栈段描述符
107		xor	eax, eax
108		mov	ax, ds
109		shl	eax, 4
110		add	eax, LABEL_STACK
111		mov	word [LABEL_DESC_STACK + 2], ax
112		shr	eax, 16
113		mov	byte [LABEL_DESC_STACK + 4], al
114		mov	byte [LABEL_DESC_STACK + 7], ah
115
116		; 为加载 GDTR 作准备
117		xor	eax, eax
118		mov	ax, ds
119		shl	eax, 4
120		add	eax, LABEL_GDT		; eax <- gdt 基地址
121		mov	dword [GdtPtr + 2], eax	; [GdtPtr + 2] <- gdt 基地址
122
123		; 加载 GDTR
124		lgdt	[GdtPtr]
125
126		; 关中断
127		cli
128
129		; 打开地址线A20
130		in	al, 92h
131		or	al, 00000010b
132		out	92h, al
133
134		; 准备切换到保护模式
135		mov	eax, cr0
136		or	eax, 1
137		mov	cr0, eax
138
139		; 真正进入保护模式
140		jmp	dword SelectorCode32:0	; 执行这一句会把 SelectorCode32 装入 cs, 并跳转到 Code32Selector:0  处
141
142	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
143
144	LABEL_REAL_ENTRY:		; 从保护模式跳回到实模式就到了这里
145		mov	ax, cs
146		mov	ds, ax
147		mov	es, ax
148		mov	ss, ax
149
150		mov	sp, [SPValueInRealMode]
151
152		in	al, 92h		; `.
153		and	al, 11111101b	;  | 关闭 A20 地址线
154		out	92h, al		; /
155
156		sti			; 开中断
157
158		mov	ax, 4c00h	; `.
159		int	21h		; /  回到 DOS
160	; END of [SECTION .s16]
161
162
163	[SECTION .s32]; 32 位代码段. 由实模式跳入.
164	[BITS	32]
165
166	LABEL_SEG_CODE32:
167		mov	ax, SelectorData
168		mov	ds, ax			; 数据段选择子
169		mov	ax, SelectorTest
170		mov	es, ax			; 测试段选择子
171		mov	ax, SelectorVideo
172		mov	gs, ax			; 视频段选择子
173
174		mov	ax, SelectorStack
175		mov	ss, ax			; 堆栈段选择子
176
177		mov	esp, TopOfStack
178
179
180		; 下面显示一个字符串
181		mov	ah, 0Ch			; 0000: 黑底    1100: 红字
182		xor	esi, esi
183		xor	edi, edi
184		mov	esi, OffsetPMMessage	; 源数据偏移
185		mov	edi, (80 * 10 + 0) * 2	; 目的数据偏移。屏幕第 10 行, 第 0 列。
186		cld
187	.1:
188		lodsb
189		test	al, al
190		jz	.2
191		mov	[gs:edi], ax
192		add	edi, 2
193		jmp	.1
194	.2:	; 显示完毕
195
196		call	DispReturn
197
198		call	TestRead
199		call	TestWrite
200		call	TestRead
201
202		; 到此停止
203		jmp	SelectorCode16:0
204
205	; ------------------------------------------------------------------------
206	TestRead:
207		xor	esi, esi
208		mov	ecx, 8
209	.loop:
210		mov	al, [es:esi]
211		call	DispAL
212		inc	esi
213		loop	.loop
214
215		call	DispReturn
216
217		ret
218	; TestRead 结束-----------------------------------------------------------
219
220
221	; ------------------------------------------------------------------------
222	TestWrite:
223		push	esi
224		push	edi
225		xor	esi, esi
226		xor	edi, edi
227		mov	esi, OffsetStrTest	; 源数据偏移
228		cld
229	.1:
230		lodsb
231		test	al, al
232		jz	.2
233		mov	[es:edi], al
234		inc	edi
235		jmp	.1
236	.2:
237
238		pop	edi
239		pop	esi
240
241		ret
242	; TestWrite 结束----------------------------------------------------------
243
244
245	; ------------------------------------------------------------------------
246	; 显示 AL 中的数字
247	; 默认地:
248	;	数字已经存在 AL 中
249	;	edi 始终指向要显示的下一个字符的位置
250	; 被改变的寄存器:
251	;	ax, edi
252	; ------------------------------------------------------------------------
253	DispAL:
254		push	ecx
255		push	edx
256
257		mov	ah, 0Ch			; 0000: 黑底    1100: 红字
258		mov	dl, al
259		shr	al, 4
260		mov	ecx, 2
261	.begin:
262		and	al, 01111b
263		cmp	al, 9
264		ja	.1
265		add	al, '0'
266		jmp	.2
267	.1:
268		sub	al, 0Ah
269		add	al, 'A'
270	.2:
271		mov	[gs:edi], ax
272		add	edi, 2
273
274		mov	al, dl
275		loop	.begin
276		add	edi, 2
277
278		pop	edx
279		pop	ecx
280
281		ret
282	; DispAL 结束-------------------------------------------------------------
283
284
285	; ------------------------------------------------------------------------
286	DispReturn:
287		push	eax
288		push	ebx
289		mov	eax, edi
290		mov	bl, 160
291		div	bl
292		and	eax, 0FFh
293		inc	eax
294		mov	bl, 160
295		mul	bl
296		mov	edi, eax
297		pop	ebx
298		pop	eax
299
300		ret
301	; DispReturn 结束---------------------------------------------------------
302
303	SegCode32Len	equ	$ - LABEL_SEG_CODE32
304	; END of [SECTION .s32]
305
306
307	; 16 位代码段. 由 32 位代码段跳入, 跳出后到实模式
308	[SECTION .s16code]
309	ALIGN	32
310	[BITS	16]
311	LABEL_SEG_CODE16:
312		; 跳回实模式:
313		mov	ax, SelectorNormal
314		mov	ds, ax
315		mov	es, ax
316		mov	fs, ax
317		mov	gs, ax
318		mov	ss, ax
319
320		mov	eax, cr0
321		and	al, 11111110b
322		mov	cr0, eax
323
324	LABEL_GO_BACK_TO_REAL:
325		jmp	0:LABEL_REAL_ENTRY	; 段地址会在程序开始处被设置成正确的值
326
327	Code16Len	equ	$ - LABEL_SEG_CODE16
328
329	; END of [SECTION .s16code]
330

```

对比之前的代码，如图所示：

![](https://raw.githubusercontent.com/dbb4560/StorePicturebed/master/wirtePicture/20191028155240.png)

新增的描述符：

- 第15行
 `LABEL_DESC_NORMAL: Descriptor    0,         0ffffh, DA_DRW    ; Normal 描述符 `
- 第17-20行： 

```

LABEL_DESC_CODE16: Descriptor    0,         0ffffh, DA_C      ; 非一致代码段, 16
LABEL_DESC_DATA:   Descriptor    0,      DataLen-1, DA_DRW    ; Data
LABEL_DESC_STACK:  Descriptor    0,     TopOfStack, DA_DRWA+DA_32; Stack, 32 位
LABEL_DESC_TEST:   Descriptor 0500000h,     0ffffh, DA_DRW

```
我们这次增加的描述符比较多，第一个是normal 描述符，第二个是16位非一致性代码描述符 ，第三个是数据段描述符，第四个是堆栈描述符，第五个是测试描述符！

总共新增加了5个描述符，描述符的分析就不详细说明了，上一章节已经有详细的说明了！


增加的描述符自然有相应的选择子和代码！


首先先看看在32位段，我们做了什么！

代码第163行处

```
[SECTION .s32]; 32 位代码段. 由实模式跳入.
[BITS	32]
```

ps：
  AH&AL＝AX：累加寄存器，常用于运算；
  BH&BL＝BX：基址寄存器，常用于地址索引；
  CH&CL＝CX：计数寄存器，常用于计数；
  DH&DL＝DX：数据寄存器，常用于数据传递。

  CS（Code Segment）：代码段寄存器；
  DS（Data Segment）：数据段寄存器；
  SS（Stack Segment）：堆栈段寄存器；
  ES（Extra Segment）：附加段寄存器。 

 DS是段寄存器 一般放的是数据段的段地址至于BX 是一个灵活的寄存器 可以用它来做许多事情 当然也可以用来当指针 楼主所谓数据段的基地址是这个段的起始地址 要说他是基地址也没有错 但是bx里放的是某个字节或字的地址用[bx]来访问。DS放段地址,BX是通用寄存器.

 ds与bx配合，es与dx配合，cx作为计数器。这既是cpu硬件设计使然，也是软件设计的标准用法，就如围棋中的定式，你必须这么用。bx是提供偏移地址。

  - IP（Instruction Pointer）：指令指针寄存器，与CS配合使用，可跟踪程序的执行过程；
  - SP（Stack Pointer）：堆栈指针，与SS配合使用，可指向目前的堆栈位置。
  - BP（Base Pointer）：基址指针寄存器，可用作SS的一个相对基址位置；
  - SI（Source Index）：源变址寄存器可用来存放相对于DS段之源变址指针；
  - DI（Destination Index）：目的变址寄存器，可用来存放相对于 ES 段之目的变址指针。

 <https://dbb4560.github.io/2019/08/09/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A03-%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BD%A2%E6%88%90/>




