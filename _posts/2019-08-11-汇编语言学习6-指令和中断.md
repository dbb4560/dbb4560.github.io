---
layout:     post
title:      汇编语言学习6
subtitle:   第一个汇编程序
date:       2019-08-11
header-img: img/post-first-blog-web.jpg
catalog: true
tags:
    - 汇编语言
    - linux
    - Intel8086
    
---
##转移指令的原理
可以修改IP，或同时修改CS和IP的指令统称为转移指令。概括地讲，转移指令就是可以控制CPU执行内存中某处代码的指令。

8086CPU的转移行为有以下几类。

- 只修改IP时，称为段内转移，比如：jmp ax。
- 同时修改CS和IP时，称为段间转移，比如：jmp 1000:0。

由于转移指令对IP的修改范围不同，段内转移又分为：短转移和近转移。

- 短转移IP的修改范围为-128~127。
- 近转移IP的修改范围为-32768~32767。

8086CPU的转移指令分为以下几类。

- 无条件转移指令（如：jmp）
- 条件转移指令
- 循环指令（如：loop）
- 过程
- 中断

###操作符offset
操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。

```
;将s处的一条指令复制到s0处
assume cs:codesg
codesg segment
 s:   mov ax, bx           ;（mov ax,bx 的机器码占两个字节）
      mov si, offset s     ;获得标号s的偏移地址
      mov di, offset s0    ;获得标号s0的偏移地址
      
      mov ax, cs:[si]
      mov cs:[di], ax
 s0:  nop                     ;（nop的机器码占一个字节）
      nop
 codesg ends
 ends
```


### jmp指令

mp为无条件转移，转到标号处执行指令可以只修改IP，也可以同时修改CS和IP；

jmp指令要给出两种信息：

- 转移的目的地址
- 转移的距离（段间转移、段内短转移，段内近转移）


`jmp short 标号 `
`jmp near ptr 标号 `
`jcxz 标号 loop 标号 `

等几种汇编指令，它们对 IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移距离。

####依据位移进行转移的jmp指令
 
`jmp short 标号（段内短转移）`

指令“jmp short 标号”的功能为(IP)=(IP)+8位位移，转到标号处执行指令

- （1）8位位移=“标号”处的地址 - jmp指令后的第一个字节的地址；

- （2）short指明此处的位移为8位位移；

- （3）8位位移的范围为-128~127，用补码表示

- （4）8位位移由编译程序在编译时算出。

```
assume cs:codesg
codesg segment
  start:mov ax,0
        jmp short s ;s不是被翻译成目的地址
        add ax, 1
      s:inc ax ;程序执行后， ax中的值为 1 
codesg ends
end start

```
执行后ax的值是1，因为jmp short s跳过add ax,1 直接指向了s，执行了inc ax，所以ax的值是1！

书中详细分析了jump 的指令，具体可以看书，意思就是jump转移的目的地址不一样，但是机器码确实一样的，比如机器码是EB 03， 这个03就是指令位移长度，上下文位移长度都是03！目前的结论如下：
CPU不需要这个目的地址就可以实现对IP的修改。这里是依据位移进行转移！

jmp short s指令的读取和执行过程：

- (CS)=0BBDH，(IP)=0006，CS:IP指向EB 03（jmp short s的机器码）；
- 读取指令码EB 03进入指令缓冲器；
- (IP)=(IP)+所读取指令的长度=(IP)+2=0008，CS:IP指向add ax,1；
- CPU指行指令缓冲器中的指令EB 03；
- 指令EB 03执行后，(IP)=000BH，CS:IP指向inc ax


位移的具体计算如图所示：
![](https://raw.githubusercontent.com/dbb4560/StorePicturebed/master/wirtePicture/image20190811200439.png)

jmp near ptr 标号 （段内近转移）

指令“jmp near ptr 标号”的功能为：(IP)=(IP)+16位位移。

- 16位位移=标号处的地址-jump指令后的第一个字节的地址；
- near ptr 指名此处的位移为16位位移，进行的是段内近转移；
- 16位位移的范围为-32768~32737,用补码表示；
- 16位位移由编译器在编译时算出；

####转移的目的地址在指令中的jmp指令
`jmp far ptr 标号`（段间转移或远转移）

指令 `jmp far ptr 标号` 功能如下：

- (CS) = 标号所在段的段地址；
- (IP) = 标号所在段中的偏移地址。
- far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。
```
assume cs:codesg
codesg segment
   start: mov ax, 0
		  mov bx, 0
          jmp far ptr  s ;s被翻译成转移的目的地址0B01 BD0B
          db 256 dup (0) ;转移的段地址：0BBDH，偏移地址：010BH
    s:    add ax,1
          inc ax
codesg ends
end start
```
调试界面显示如下。可以看出这个包含了转移的目的地址。
![](https://raw.githubusercontent.com/dbb4560/StorePicturebed/master/wirtePicture/image20190811201233.png)

####转移地址在寄存器或内存中的jmp指令
`jmp 16位寄存器 功能：IP =（16位寄存器）`

转移地址在内存中的jmp指令有两种格式：

- jmp word ptr 内存单元地址（段内转移）
功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。

```
mov ax, 0123H
mov ds:[0], ax
jmp word ptr ds:[0]
;执行后，(IP)=0123H
```
- jmp dword ptr 内存单元地址（段间转移）

功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。

 1. (CS)=(内存单元地址+2)
 2. (IP)=(内存单元地址)
```
mov ax, 0123H
mov ds:[0], ax;偏移地址
mov word ptr ds:[2], 0;段地址
jmp dword ptr ds:[0]
;执行后，
;(CS)=0
;(IP)=0123H
;CS:IP 指向 0000:0123。
```
####jcxz指令和loop指令

jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移。
在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127。
指令格式：jcxz 标号（如果(cx)=0，则转移到标号处执行。）
当(cx) = 0时，(IP) = (IP) + 8位位移
- 8位位移 = “标号”处的地址 - jcxz指令后的第一个字节的地址；
- 8位位移的范围为-128~127，用补码表示；
- 8位位移由编译程序在编译时算出。

当(cx)!=0时，什么也不做（程序向下执行）。

loop指令
loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。

对IP的修改范围都为-128~127。

指令格式：loop 标号 ((cx)) = (cx) - 1，如果(cx) ≠ 0，转移到标号处执行。
(cx) = (cx) - 1；如果 (cx) != 0，(IP)=(IP) + 8位位移。
- 8位位移=标号处的地址-loop指令后的第一个字节的地址；
- 8位位移的范围为-128~127，用补码表示；
- 8位位移由编译程序在编译时算出。

如果（cx）= 0，什么也不做（程序向下执行）。

##call和ret指令
call和ret指令都是转移指令，它们都修改IP，或同时修改CS和IP。常用来设计子程序。
####ret和retf
这个要结合前面的栈操作知识点看，就知道为什么有两步了！
- ret指令用栈中的数据，修改IP的内容，从而实现近转移；
- retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。

CPU执行ret指令时，相当于进行： pop IP：

- （1）(IP) = ( (ss) * 16 + (sp) )

- （2）(sp) = (sp) + 2

CPU执行retf指令时，相当于进行：pop IP, pop CS：

- （1）(IP) = ( (ss) * 16 + (sp) )

- （2）(sp) = (sp) + 2

- （3）(CS) = ( (ss) * 16 + (sp) )

- （4）(sp) = (sp) + 2


```
assume cs:code 
stack seqment
	db 16 dup (0)
stack ends 

code segment
		mov ax, 4c00h
		int 21h 
 start:	mov ax, stack 
 		mov ss, ax
 		mov sp, 16 ;栈顶指针指向栈底
		mov ax, 0
		push ax ;ax入栈
		mov bx, 0
		ret ;ret指令执行后，(IP)=0，CS:IP指向代码段的第一条指令。可以push cs  push ax  retf
code ends
end start
```

####call 指令
all指令经常跟ret指令配合使用，因此CPU执行call指令，进行两步操作：

（1）将当前的 IP 或 CS和IP 压入栈中；

（2）转移（jmp）。

call指令不能实现短转移，除此之外，call指令实现转移的方法和 jmp 指令的原理相同。

call 标号（近转移）

CPU执行此种格式的call指令时，相当于进行：
 - push IP 
 - jmp near ptr 标号

call far ptr标号（段间转移）

CPU执行此种格式的call指令时，相当于进行：
- push CS
- push IP
- jmp far ptr 标号

call 16位寄存器

CPU执行此种格式的call指令时，相当于进行： 
-push IP 
-jmp 16位寄存器

call word ptr 内存单元地址

CPU执行此种格式的call指令时，相当于进行：
- push IP
- jmp word ptr 内存单元地址
- 
```
mov sp, 10h
mov ax, 0123h
mov ds:[0], ax
call word ptr ds:[0]
;执行后，(IP)=0123H，(sp)=0EH
```

call dword ptr 内存单元地址

CPU执行此种格式的call指令时，相当于进行：push CS push IP jmp dword ptr 内存单元地址
```
mov sp, 10h
mov ax, 0123h
mov ds:[0], ax
mov word ptr ds:[2], 0
call dword ptr ds:[0]
;执行后，(CS)=0，(IP)=0123H，(sp)=0CH
```

####call 和 ret 的配合使用
分析下面程序:
```
assume cs:code
code segment
start:	mov ax,1
	    mov cx,3
     	call s ;（1）CPU指令缓冲器存放call指令，IP指向下一条指令（mov bx, ax），执行call指令，IP值（指令mov  bx,ax的偏移地址）入栈，jmp（将IP的值改变为标号s处的偏移地址）
     	
	    mov bx,ax	;（4）IP重新指向这里  bx = 8
     	mov ax,4c00h
     	int 21h
     s: add ax,ax  
     	loop s;（2）循环3次ax = 8
	    ret;（3）return : pop IP 就是之前压入的Ip地址 mov bx,ax的值，送入IP 中，这样吓一跳指令就是mov bx,ax 这就是为什么call ret 通常用来设计子程序的原因了
code ends
end start

```

call 与 ret 指令共同支持了汇编语言编程中的模块化设计

编写子程序，书中也写了模块设计东东，批量数据东东，编写子程序东东，这个不在我们考虑范围内了，能看得懂就可以了，现在哪家公司很少让你改的，也不敢让你改的，很成熟的东东了!

##标志寄存器

CPU内部的寄存器中，有一种特殊的寄存器（对于不同的处理机，个数和结构都可能不同）具有以下3种作用。

- （1）用来存储相关指令的某些执行结果；

- （2）用来为CPU执行相关指令提供行为依据；

- （3）用来控制CPU的相关工作方式。

这种特殊的寄存器在8086CPU中，被称为标志寄存器（flag）。其实很多单片机都有这种flag的啦！

8086CPU的标志寄存器有16位，其中存储的信息通常被称为程序状态字（PSW）

flag寄存器是按位起作用的，它的每一位都有专门的含义，记录特定的信息。
![](https://raw.githubusercontent.com/dbb4560/StorePicturebed/master/wirtePicture/image20190811214732.png)

在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如，add、sub、mul、div、inc、or、and等，它们大都是运算指令（进行逻辑或算术运算）；有的指令的执行对标志寄存器没有影响，比如，mov、push、pop等，它们大都是传送指令。

####ZF

零标志位。它记录相关指令执行后，其结果是否为0。

如果结果为0，那么zf = 1(表示结果是0)；如果结果不为0，那么zf=0。

```
mov ax, 1
sub ax, 1 ;执行后，结果为0，则zf=1

mov ax, 2
sub ax, 1 ;执行后，结果不为0，则zf=0
```
####PF
奇偶标志位。它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。

如果1的个数为偶数，pf=1，如果为奇数，那么pf=0。
```
mov al, 1
add al, 10 ;执行后，结果为00001011B，其中有3（奇数）个1，则pf=0；

mov al, 1
or al, 2  ;执行后，结果为00000011B，其中有2（偶数）个1，则pf=1；
```

####SF
符号标志位。它记录相关指令执行后，其结果是否为负。

如果结果为负，sf=1；如果非负，sf=0。

计算机中通常用补码来表示有符号数据。计算机中的一个数据可以看作是有符号数，也可以看成是无符号数。

- 00000001B，可以看作为无符号数1，或有符号数+1；
- 10000001B，可以看作为无符号数129，也可以看作有符号数-127。

**对于同一个二进制数据，计算机可以将它当作无符号数据来运算，也可以当作有符号数据来运算**

**CPU在执行add等指令的时候，就包含了两种含义:可以将add指令进行的运算当作无符号数的运算，也可以将add指令进行的运算当作有符号数的运算**


SF标志，就是CPU对有符号数运算结果的一种记录，它记录数据的正负。在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。如果我们将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值。
```
mov al, 10000001B 
add al, 1   ;执行后，结果为10000010B，sf=1，表示：如果指令进行的是有符号数运算，那么结果为负；
```

```
mov al, 10000001B
add al, 01111111B   ;执行后，结果为0，sf=0，表示：如果指令进行的是有符号数运算，那么结果为非负
```

####CF
进位标志位。一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。
![](https://raw.githubusercontent.com/dbb4560/StorePicturebed/master/wirtePicture/image20190811215221.png)

97H - 98H 产生借位CF = 1 ==》 (al) = 197H - 98H = FFH。

####OF

溢出标志位。一般情况下，OF记录了**有符号**数运算的结果是否发生了溢出。

如果发生溢出，OF=1；如果没有，OF=0。

CF和OF的区别：CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位

CPU在执行add等指令的时候，就包含了两种含义：无符号数运算和有符号数运算。对于无符号数运算，CPU用CF位来记录是否产生了进位；对于有符号数运算，CPU用OF位来记录是否产生了溢出，当然，还要用SF位来记录结果的符号。
```
mov al, 98
add al, 99   ;执行后将产生溢出。因为进行的"有符号数"运算是：（al）=（al）+ 99 = 98 + 99=197 = C5H 为-59的补码
             ;而结果197超出了机器所能表示的8位有符号数的范围：-128-127。
             ;add 指令执行后：无符号运算没有进位CF=0，有符号运算溢出OF=1
             ;当取出的数据C5H按无符号解析C5H = 197, 当按有符号解析通过SP得知数据为负,即C5H为-59补码存储，
             
mov al，0F0H  ;FOH，为有符号数-16的补码   -Not(F0 - 1)
add al，088H  ;88H，为有符号数-120的补码   -Not(88- 1)
              ;执行后，将产生溢出。因为add al，088H进行的有符号数运算结果是：（al）= -136 
              ;而结果-136超出了机器所能表示的8位有符号数的范围：-128-127。
              ;add 指令执行后：无符号运算有进位CF=1，有符号运算溢出OF=1

```

####adc指令和sbb指令
adc是带进位加法指令，它利用了CF位上记录的进位值。

指令格式：`adc 操作对象1, 操作对象2`

功能：操作对象1 = 操作对象1 + 操作对象2 + CF。
```
mov ax, 2
mov bx, 1
sub bx, ax  ;无符号运算借位CF=1，有符号运算OF = 0
adc ax, 1   ;执行后，（ax）= 4。adc执行时，相当于计算：(ax)+1+CF=2+1+1=4。
```


![](https://raw.githubusercontent.com/dbb4560/StorePicturebed/master/wirtePicture/image20190811215540.png)

```
;计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）中。
;将计算分两步进行，先将低16位相加，然后将高16位和进位值相加。
mov ax, 001EH 
mov bx, 0F000H 
add bx, 1000H
adc ax, 0020H
```
####sbb指令
sbb是带借位减法指令，它利用了CF位上记录的借位值。

指令格式：`sbb 操作对象1, 操作对象2`

功能：操作对象1 = 操作对象1 - 操作对象2 - CF
```
;计算003E1000H-00202000H，结果放在ax，bx中，程序如下：
mov bx, 1000H
mov ax, 003EH
sub bx, 2000H
sbb ax, 0020H
```
