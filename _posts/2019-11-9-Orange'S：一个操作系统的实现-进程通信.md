---
layout:     post
title:      Orange'S：一个操作系统的实现
subtitle:   进程
date:       2019-11-09
header-img: img/post-first-blog-web.jpg
catalog: true
tags:
    - x86
    - 操作系统
    - 进程通信

---

### 进程通讯

这里有宏内核和微内核。

微内核的基本思想就是将内核工作简单化的思想！

宏内核 就是所有工作通过系统调用扔给内核态的做法。

 
基于宏内核的操作系统之，完成剧吐任务时，用户进程通过系统调用让内核来做事，直来直去。

基于微内核的操作系统中，这个是过程就稍微复杂一些。在完成具体任务时，内核的角色很象个中介。

比如要实现的文件系统，设想用户进程P读取一个文件，首先通过内核告诉进程FS ，然后FS 在通过内核告诉驱动程序（也是一个独立的进程），驱动程序读取硬盘，返回结果。这样一来，一项工作的完成就变得曲折，需要进程协同工作，所以进程间通信就很重要了！

操作系统要管理磁盘和磁盘上的文件并管理内存等等，这些都要给应用程序提供接口了。

书上举例看看两个内核是什么样！


现有的微内核和宏内核的例子，minix是微内核的！ linux 就是宏内核的！


老一点的操作系统都是宏内核的，整个操作系统是一个运行在核心态的单独的a.out文件，这个二进制包含进程管理、内存管理、文件系统以及其他。
具体实例包括UNIX、 MS_DOS、VMS、OS/360、MULTICS等等！

另外一个就是微内核，操作系统大部分都运行在单独的进程，而且多数在内核之外。它们之间通过消息传递来通信。内核的任务是处理消息传递、中断处理、底层的进程管理，以及还没有发布的windows /NT。


minix是i微内核的，文件系统和内存管理是单独的进程，运行在内核之外。I/O 驱动也是单独的进程！


通过系统调用看看两者区别

宏内核是拿linux0.01 
微内核是拿minx 

都用fork系统调用举例！


书上选择了微内核，我个人也觉得微内核很符合我们嵌入式系统的工作，通过也方便扩展的话，其他的缺点都不是问题！

### IPC 

IPC 是inter-process Communication的缩写，就是进程间通信，进程间发消息！
有同步IPC 和 异步IPC


实现IPC ， minix 的IPC 机制，核心在于“int SYSVEC” 这个软中断和与之对应的sys_call()函数。

具体请看书上解释所示，还是make 运行上图验证！

代码第8章 a节
使用IPC 实现get_ticks,

![](https://raw.githubusercontent.com/dbb4560/StorePicturebed/master/wirtePicture/20191204105546.png)



代码相对很独立，结构很清晰。并且内核态的代码很少需要大的改动了。






